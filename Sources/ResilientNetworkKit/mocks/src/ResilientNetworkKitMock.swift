///
/// @Generated by Mockolo
///

import Foundation
import ResilientNetworkKit

// MARK: - ResponseParserMock

public class ResponseParserMock: ResponseParser {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public private(set) var parseCallCount = 0
  public var parseHandler: ((Data) throws -> Any)?

  public func parse<T: Decodable>(data: Data) throws -> T {
    parseCallCount += 1
    if let parseHandler {
      return try parseHandler(data) as! T
    }
    fatalError("parseHandler returns can't have a default value thus its handler must be set")
  }
}

// MARK: - ErrorInterceptorMock

public final class ErrorInterceptorMock: ErrorInterceptor, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var interceptCallCount: Int {
    interceptState.withLock(\.callCount)
  }

  public var interceptHandler: (@Sendable (Error?, Any) -> ResilientNetworkKitError?)? {
    get { interceptState.withLock(\.handler) }
    set { interceptState.withLock { $0.handler = newValue } }
  }

  public func intercept(_ error: Error?, endpoint: some Endpoint) -> ResilientNetworkKitError? {
    let interceptHandler = interceptState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let interceptHandler {
      return interceptHandler(error, endpoint)
    }
    return nil
  }

  // MARK: Private

  private let interceptState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Error?, Any) -> ResilientNetworkKitError?>())
}

// MARK: - MetricInterceptorMock

public class MetricInterceptorMock: MetricInterceptor {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public private(set) var notifyCallCount = 0
  public var notifyHandler: ((URLSessionTaskMetricsProtocol) -> Void)?

  public func notify(metrics: URLSessionTaskMetricsProtocol) {
    notifyCallCount += 1
    if let notifyHandler {
      notifyHandler(metrics)
    }
  }
}

// MARK: - RequestInterceptorMock

public final class RequestInterceptorMock: RequestInterceptor, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var modifyCallCount: Int {
    modifyState.withLock(\.callCount)
  }

  public var modifyHandler: (@Sendable (Any) -> Any)? {
    get { modifyState.withLock(\.handler) }
    set { modifyState.withLock { $0.handler = newValue } }
  }

  public func modify<E: Endpoint>(endpoint: E) -> E {
    let modifyHandler = modifyState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let modifyHandler {
      return modifyHandler(endpoint) as! E
    }
    fatalError("modifyHandler returns can't have a default value thus its handler must be set")
  }

  // MARK: Private

  private let modifyState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Any) -> Any>())
}

// MARK: - RedirectInterceptorMock

public class RedirectInterceptorMock: RedirectInterceptor {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public private(set) var verifyRedirectCallCount = 0
  public var verifyRedirectHandler: ((URLRequest?, URLRequest, @escaping (URLRequest?) -> Void) -> Void)?

  public func verifyRedirect(from originalRequest: URLRequest?, newRequest request: URLRequest, completionHandler: @escaping (URLRequest?) -> Void) {
    verifyRedirectCallCount += 1
    if let verifyRedirectHandler {
      verifyRedirectHandler(originalRequest, request, completionHandler)
    }
  }
}

// MARK: - ConflictJustifierMock

public final class ConflictJustifierMock: ConflictJustifier, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var justifyCallCount: Int {
    justifyState.withLock(\.callCount)
  }

  public var justifyHandler: (@Sendable (Data?) -> ResilientNetworkKitError)? {
    get { justifyState.withLock(\.handler) }
    set { justifyState.withLock { $0.handler = newValue } }
  }

  public func justify(payload data: Data?) -> ResilientNetworkKitError {
    let justifyHandler = justifyState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let justifyHandler {
      return justifyHandler(data)
    }
    fatalError("justifyHandler returns can't have a default value thus its handler must be set")
  }

  // MARK: Private

  private let justifyState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Data?) -> ResilientNetworkKitError>())
}

// MARK: - NetworkTraceInspectorMock

public final class NetworkTraceInspectorMock: NetworkTraceInspector, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var addCallCount: Int {
    addState.withLock(\.callCount)
  }

  public var addHandler: (@Sendable (Any, TimeInterval, TimeInterval?, NetworkRequestStatus, HTTPURLResponse?, Data?, ResilientNetworkKitError?) -> Void)? {
    get { addState.withLock(\.handler) }
    set { addState.withLock { $0.handler = newValue } }
  }

  public var updateCallCount: Int {
    updateState.withLock(\.callCount)
  }

  public var updateHandler: (@Sendable (Any, TimeInterval, TimeInterval, HTTPURLResponse?, Data?, ResilientNetworkKitError?) -> Void)? {
    get { updateState.withLock(\.handler) }
    set { updateState.withLock { $0.handler = newValue } }
  }

  public var clearAllCallCount: Int {
    clearAllState.withLock(\.callCount)
  }

  public var clearAllHandler: (@Sendable () -> Void)? {
    get { clearAllState.withLock(\.handler) }
    set { clearAllState.withLock { $0.handler = newValue } }
  }

  public func add(endpoint: some Endpoint, startTime: TimeInterval, endTime: TimeInterval?, status: NetworkRequestStatus, httpURLResponse: HTTPURLResponse?, data: Data?, error: ResilientNetworkKitError?) {
    let addHandler = addState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let addHandler {
      addHandler(endpoint, startTime, endTime, status, httpURLResponse, data, error)
    }
  }

  public func update(endpoint: some Endpoint, startTime: TimeInterval, endTime: TimeInterval, httpURLResponse: HTTPURLResponse?, data: Data?, error: ResilientNetworkKitError?) {
    let updateHandler = updateState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let updateHandler {
      updateHandler(endpoint, startTime, endTime, httpURLResponse, data, error)
    }
  }

  public func clearAll() {
    let clearAllHandler = clearAllState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let clearAllHandler {
      clearAllHandler()
    }
  }

  // MARK: Private

  private let addState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Any, TimeInterval, TimeInterval?, NetworkRequestStatus, HTTPURLResponse?, Data?, ResilientNetworkKitError?) -> Void>())

  private let updateState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Any, TimeInterval, TimeInterval, HTTPURLResponse?, Data?, ResilientNetworkKitError?) -> Void>())

  private let clearAllState = MockoloMutex(MockoloHandlerState<Never, @Sendable () -> Void>())
}

// MARK: - ResponseErrorInspectorMock

public final class ResponseErrorInspectorMock: ResponseErrorInspector, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var inspectCallCount: Int {
    inspectState.withLock(\.callCount)
  }

  public var inspectHandler: (@Sendable (Data?, Any) -> Any)? {
    get { inspectState.withLock(\.handler) }
    set { inspectState.withLock { $0.handler = newValue } }
  }

  public func inspect(_ data: Data?, endpoint: some Endpoint) -> Any {
    let inspectHandler = inspectState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let inspectHandler {
      return inspectHandler(data, endpoint)
    }
    fatalError("inspectHandler returns can't have a default value thus its handler must be set")
  }

  // MARK: Private

  private let inspectState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Data?, Any) -> Any>())
}

// MARK: - AdvancedRetryInterceptorMock

public final class AdvancedRetryInterceptorMock: AdvancedRetryInterceptor, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var getRetryPolicyCallCount: Int {
    getRetryPolicyState.withLock(\.callCount)
  }

  public var getRetryPolicyHandler: (@Sendable (Any, ResilientNetworkKitError) -> RetryPolicy?)? {
    get { getRetryPolicyState.withLock(\.handler) }
    set { getRetryPolicyState.withLock { $0.handler = newValue } }
  }

  public func getRetryPolicy(_ endPoint: some Endpoint, error: ResilientNetworkKitError) -> RetryPolicy? {
    let getRetryPolicyHandler = getRetryPolicyState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let getRetryPolicyHandler {
      return getRetryPolicyHandler(endPoint, error)
    }
    return nil
  }

  // MARK: Private

  private let getRetryPolicyState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Any, ResilientNetworkKitError) -> RetryPolicy?>())
}

// MARK: - ResponseParserInterceptorMock

public final class ResponseParserInterceptorMock: ResponseParserInterceptor, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var interceptCallCount: Int {
    interceptState.withLock(\.callCount)
  }

  public var interceptHandler: (@Sendable (Data?, Any) throws -> Any)? {
    get { interceptState.withLock(\.handler) }
    set { interceptState.withLock { $0.handler = newValue } }
  }

  public func intercept<E: Endpoint>(_ data: Data?, endpoint: E) throws -> E.Response {
    let interceptHandler = interceptState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let interceptHandler {
      return try interceptHandler(data, endpoint) as! E.Response
    }
    fatalError("interceptHandler returns can't have a default value thus its handler must be set")
  }

  // MARK: Private

  private let interceptState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Data?, Any) throws -> Any>())
}

// MARK: - ResponseStatusInterceptorMock

public final class ResponseStatusInterceptorMock: ResponseStatusInterceptor, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var interceptCallCount: Int {
    interceptState.withLock(\.callCount)
  }

  public var interceptHandler: (@Sendable (HTTPURLResponse, Any) -> StatusCode)? {
    get { interceptState.withLock(\.handler) }
    set { interceptState.withLock { $0.handler = newValue } }
  }

  public func intercept(_ response: HTTPURLResponse, endpoint: some Endpoint) -> StatusCode {
    let interceptHandler = interceptState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let interceptHandler {
      return interceptHandler(response, endpoint)
    }
    fatalError("interceptHandler returns can't have a default value thus its handler must be set")
  }

  // MARK: Private

  private let interceptState = MockoloMutex(MockoloHandlerState<Never, @Sendable (HTTPURLResponse, Any) -> StatusCode>())
}

// MARK: - TokenRefreshingInterceptorMock

public final class TokenRefreshingInterceptorMock: TokenRefreshingInterceptor, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var refreshAccessTokenCallCount: Int {
    refreshAccessTokenState.withLock(\.callCount)
  }

  public var refreshAccessTokenHandler: (@Sendable (@Sendable @escaping (Result<Void, ResilientNetworkKitError>) -> Void) -> Void)? {
    get { refreshAccessTokenState.withLock(\.handler) }
    set { refreshAccessTokenState.withLock { $0.handler = newValue } }
  }

  public func refreshAccessToken(completion: @Sendable @escaping (Result<Void, ResilientNetworkKitError>) -> Void) {
    let refreshAccessTokenHandler = refreshAccessTokenState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let refreshAccessTokenHandler {
      refreshAccessTokenHandler(completion)
    }
  }

  // MARK: Private

  private let refreshAccessTokenState = MockoloMutex(MockoloHandlerState<Never, @Sendable (@Sendable @escaping (Result<Void, ResilientNetworkKitError>) -> Void) -> Void>())
}

// MARK: - ResponseMonitorInterceptorMock

public final class ResponseMonitorInterceptorMock: ResponseMonitorInterceptor, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var monitorResponseCallCount: Int {
    monitorResponseState.withLock(\.callCount)
  }

  public var monitorResponseHandler: (@Sendable (Any, HTTPURLResponse?, Error?, Data?, TimeInterval, TimeInterval) -> Void)? {
    get { monitorResponseState.withLock(\.handler) }
    set { monitorResponseState.withLock { $0.handler = newValue } }
  }

  public func monitorResponse(endpoint: some Endpoint, response: HTTPURLResponse?, error: Error?, data: Data?, requestStartTime: TimeInterval, requestEndTime: TimeInterval) {
    let monitorResponseHandler = monitorResponseState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let monitorResponseHandler {
      monitorResponseHandler(endpoint, response, error, data, requestStartTime, requestEndTime)
    }
  }

  // MARK: Private

  private let monitorResponseState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Any, HTTPURLResponse?, Error?, Data?, TimeInterval, TimeInterval) -> Void>())
}

// MARK: - URLSessionTaskMetricsProtocolMock

public class URLSessionTaskMetricsProtocolMock: URLSessionTaskMetricsProtocol {
  // MARK: Lifecycle

  public init() {}
  public init(taskInterval: DateInterval, transactionMetrics: [URLSessionTaskTransactionMetrics] = [URLSessionTaskTransactionMetrics](), countOfBytesReceived: Int64 = 0, countOfBytesSent: Int64 = 0) {
    _taskInterval = taskInterval
    self.transactionMetrics = transactionMetrics
    self.countOfBytesReceived = countOfBytesReceived
    self.countOfBytesSent = countOfBytesSent
  }

  // MARK: Public

  public var transactionMetrics = [URLSessionTaskTransactionMetrics]()

  public var countOfBytesReceived: Int64 = 0

  public var countOfBytesSent: Int64 = 0

  public var taskInterval: DateInterval {
    get { _taskInterval }
    set { _taskInterval = newValue }
  }

  // MARK: Private

  private var _taskInterval: DateInterval!
}

// MARK: - ResilientNetworkKitMock

public final class ResilientNetworkKitMock: ResilientNetworkKit, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var sendCallCount: Int {
    sendState.withLock(\.callCount)
  }

  public var sendHandler: (@Sendable (Any, RetryPolicy, DispatchQueueType) async throws -> Any)? {
    get { sendState.withLock(\.handler) }
    set { sendState.withLock { $0.handler = newValue } }
  }

  public var sendEndpointCallCount: Int {
    sendEndpointState.withLock(\.callCount)
  }

  public var sendEndpointHandler: (@Sendable (Any, RetryPolicy, DispatchQueueType, @Sendable @escaping (Result<(Any, Int, ResilientNetworkKitHeaders), ResilientNetworkKitError>) -> Void) -> Void)? {
    get { sendEndpointState.withLock(\.handler) }
    set { sendEndpointState.withLock { $0.handler = newValue } }
  }

  public var cancelAllRequestCallCount: Int {
    cancelAllRequestState.withLock(\.callCount)
  }

  public var cancelAllRequestHandler: (@Sendable (DispatchQueueType, (@Sendable () -> Void)?) -> Void)? {
    get { cancelAllRequestState.withLock(\.handler) }
    set { cancelAllRequestState.withLock { $0.handler = newValue } }
  }

  public func send<E: Endpoint>(_ endpoint: E, retry: RetryPolicy, receiveOn queue: DispatchQueueType) async throws -> (E.Response, Int, ResilientNetworkKitHeaders) {
    let sendHandler = sendState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let sendHandler {
      return try await sendHandler(endpoint, retry, queue) as! (E.Response, Int, ResilientNetworkKitHeaders)
    }
    fatalError("sendHandler returns can't have a default value thus its handler must be set")
  }

  public func send<E: Endpoint>(_ endpoint: E, retry: RetryPolicy, receiveOn queue: DispatchQueueType, completion: @Sendable @escaping (Result<(E.Response, Int, ResilientNetworkKitHeaders), ResilientNetworkKitError>) -> Void) {
    let sendEndpointHandler = sendEndpointState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let sendEndpointHandler, let callback = completion as? @Sendable (Result<(Any, Int, ResilientNetworkKitHeaders), ResilientNetworkKitError>) -> Void {
      sendEndpointHandler(endpoint, retry, queue, callback)
    }
  }

  public func cancelAllRequest(completingOn queue: DispatchQueueType, completion: (@Sendable () -> Void)?) {
    let cancelAllRequestHandler = cancelAllRequestState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let cancelAllRequestHandler {
      cancelAllRequestHandler(queue, completion)
    }
  }

  // MARK: Private

  private let sendState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Any, RetryPolicy, DispatchQueueType) async throws -> Any>())

  private let sendEndpointState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Any, RetryPolicy, DispatchQueueType, @Sendable @escaping (Result<(Any, Int, ResilientNetworkKitHeaders), ResilientNetworkKitError>) -> Void) -> Void>())
  private let cancelAllRequestState = MockoloMutex(MockoloHandlerState<Never, @Sendable (DispatchQueueType, (@Sendable () -> Void)?) -> Void>())
}

private func warnIfNotSendable<each T>(function: String = #function, _: repeat each T) {
  print("At \(function), the captured arguments are not Sendable, it is not concurrency-safe.")
}

private func warnIfNotSendable<each T: Sendable>(function: String = #function, _: repeat each T) {}

// MARK: - MockoloMutex

/// Will be replaced to `Synchronization.Mutex` in future.
private final class MockoloMutex<Value>: @unchecked Sendable {
  // MARK: Lifecycle

  init(_ initialValue: Value) {
    value = initialValue
  }

  // MARK: Internal

  #if compiler(>=6.0)
  borrowing func withLock<Result, E: Error>(_ body: (inout sending Value) throws(E) -> Result) throws(E) -> sending Result {
    lock.lock()
    defer { lock.unlock() }
    return try body(&value)
  }
  #else
  func withLock<Result>(_ body: (inout Value) throws -> Result) rethrows -> Result {
    lock.lock()
    defer { lock.unlock() }
    return try body(&value)
  }
  #endif

  // MARK: Private

  private let lock = NSLock()
  private var value: Value
}

// MARK: - MockoloUnsafeTransfer

private struct MockoloUnsafeTransfer<Value>: @unchecked Sendable {
  // MARK: Lifecycle

  init(_ value: Value) {
    self.value = value
  }

  // MARK: Internal

  var value: Value
}

// MARK: - MockoloHandlerState

private struct MockoloHandlerState<Arg, Handler> {
  var argValues: [MockoloUnsafeTransfer<Arg>] = []
  var handler: Handler?
  var callCount = 0
}
